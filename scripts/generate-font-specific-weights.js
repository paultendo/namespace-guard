#!/usr/bin/env node

/**
 * generate-font-specific-weights.js
 *
 * Converts font-specific-weights.json (from confusable-vision) into a TypeScript
 * file exporting a FONT_SPECIFIC_WEIGHTS constant for use by namespace-guard.
 *
 * Each font's data uses the existing ConfusableWeights type (nested
 * Record<string, Record<string, ConfusableWeight>>). For font-specific entries:
 *   - danger = the font-specific SSIM score
 *   - stableDanger = same value (single font, no aggregation)
 *   - cost = 1 - danger
 *
 * Only includes pairs with SSIM >= 0.7 (the high-risk threshold).
 *
 * Usage:
 *   node scripts/generate-font-specific-weights.js [path-to-json]
 *
 * Default path: ../confusable-vision/data/output/font-specific-weights.json
 */

const fs = require("node:fs");
const path = require("node:path");

const DEFAULT_JSON_PATH = path.resolve(
  __dirname,
  "../../confusable-vision/data/output/font-specific-weights.json"
);

const OUTPUT_PATH = path.resolve(__dirname, "../src/font-specific-weights.ts");

const SSIM_THRESHOLD = 0.7;

const jsonPath = process.argv[2] || DEFAULT_JSON_PATH;

if (!fs.existsSync(jsonPath)) {
  console.error(`Input file not found: ${jsonPath}`);
  console.error("Run confusable-vision generate-font-weights.ts first.");
  process.exit(1);
}

const data = JSON.parse(fs.readFileSync(jsonPath, "utf-8"));

// Escape a character to a safe JS string representation
function escapeChar(ch) {
  const cp = ch.codePointAt(0);
  if (cp >= 0x20 && cp <= 0x7e && ch !== '"' && ch !== "\\") {
    return ch;
  }
  if (cp <= 0xffff) {
    return "\\u" + cp.toString(16).padStart(4, "0");
  }
  // Surrogate pair for SMP characters
  const hi = Math.floor((cp - 0x10000) / 0x400) + 0xd800;
  const lo = ((cp - 0x10000) % 0x400) + 0xdc00;
  return (
    "\\u" +
    hi.toString(16).padStart(4, "0") +
    "\\u" +
    lo.toString(16).padStart(4, "0")
  );
}

function round(n) {
  return Math.round(n * 10000) / 10000;
}

// Count total high-risk pairs across all fonts
let totalHighRiskEdges = 0;
let totalFonts = 0;

// Generate TypeScript source
let ts = `// Auto-generated by scripts/generate-font-specific-weights.js
// Source: confusable-vision font-specific-weights.json (${data.meta.fontCount} fonts, ${data.meta.totalUniquePairs} unique pairs)
// Generated: ${new Date().toISOString()}
//
// DO NOT EDIT MANUALLY. Regenerate with:
//   node scripts/generate-font-specific-weights.js
//
// LICENCE: This data is derived from confusable-vision output and is
// licensed under CC-BY-4.0 (https://creativecommons.org/licenses/by/4.0/).
// Attribution: Paul Wood FRSA (@paultendo), confusable-vision
// (https://github.com/paultendo/confusable-vision).
// The surrounding namespace-guard code is MIT-licensed.

import type { ConfusableWeights } from "./index";

/**
 * Per-font confusable weight maps for ${data.meta.fontCount} macOS system fonts.
 *
 * Each font's map contains only the high-risk pairs (SSIM >= ${SSIM_THRESHOLD}) that
 * are visually confusable when the target character renders in that specific font.
 * This gives 10-28x less data than the universal CONFUSABLE_WEIGHTS map.
 *
 * Usage:
 *   import { FONT_SPECIFIC_WEIGHTS } from "namespace-guard/font-specific-weights";
 *   const weights = FONT_SPECIFIC_WEIGHTS["Arial"];
 *
 * Platform: ${data.meta.platform} (${data.meta.fontSetId})
 *
 * @licence CC-BY-4.0 (data); MIT (code)
 * @attribution Paul Wood FRSA, confusable-vision
 * @see https://github.com/paultendo/confusable-vision
 */
export const FONT_SPECIFIC_WEIGHTS: Record<string, ConfusableWeights> = {\n`;

const fontNames = Object.keys(data.fonts).sort();

for (const fontName of fontNames) {
  const fontData = data.fonts[fontName];
  const highRiskEdges = fontData.edges.filter((e) => e.ssim >= SSIM_THRESHOLD);

  if (highRiskEdges.length === 0) continue;

  totalFonts++;
  totalHighRiskEdges += highRiskEdges.length;

  // Build nested map: source char -> target char -> weight
  const map = {};
  for (const edge of highRiskEdges) {
    const src = edge.source;
    const tgt = edge.target;

    if (!map[src]) map[src] = {};

    const danger = round(edge.ssim);
    const cost = round(Math.max(0, Math.min(1, 1 - danger)));

    map[src][tgt] = {
      danger,
      stableDanger: danger,
      cost,
      ...(edge.xidContinue ? { xidContinue: true } : {}),
      ...(edge.idnaPvalid ? { idnaPvalid: true } : {}),
      ...(edge.tr39Allowed ? { tr39Allowed: true } : {}),
    };
  }

  // Escape the font name for use as a JS property key
  const escapedFontName = fontName.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
  ts += `  "${escapedFontName}": {\n`;

  const sources = Object.keys(map).sort(
    (a, b) => a.codePointAt(0) - b.codePointAt(0)
  );

  for (const src of sources) {
    const targets = map[src];
    const targetKeys = Object.keys(targets).sort();

    ts += `    "${escapeChar(src)}": {\n`;

    for (const tgt of targetKeys) {
      const w = targets[tgt];
      const fields = [];
      fields.push(`danger:${w.danger}`);
      fields.push(`stableDanger:${w.stableDanger}`);
      fields.push(`cost:${w.cost}`);
      if (w.xidContinue) fields.push("xidContinue:true");
      if (w.idnaPvalid) fields.push("idnaPvalid:true");
      if (w.tr39Allowed) fields.push("tr39Allowed:true");

      ts += `      "${escapeChar(tgt)}": {${fields.join(",")}},\n`;
    }

    ts += "    },\n";
  }

  ts += "  },\n";
}

ts += "};\n";

fs.writeFileSync(OUTPUT_PATH, ts);

const stats = fs.statSync(OUTPUT_PATH);
console.log(`Generated: ${OUTPUT_PATH}`);
console.log(
  `  ${totalFonts} fonts with high-risk pairs (of ${data.meta.fontCount} total)`
);
console.log(`  ${totalHighRiskEdges} total high-risk edges across all fonts`);
console.log(`  File size: ${(stats.size / 1024).toFixed(1)} KB`);
