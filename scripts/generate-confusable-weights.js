#!/usr/bin/env node

/**
 * generate-confusable-weights.js
 *
 * Converts confusable-weights.json (from confusable-vision) into a TypeScript
 * file exporting a CONFUSABLE_WEIGHTS constant for use by namespace-guard.
 *
 * The output is a Record<string, Record<string, ConfusableWeight>> keyed by
 * source char -> target char.
 *
 * Usage:
 *   node scripts/generate-confusable-weights.js [path-to-json]
 *
 * Default path: ../confusable-vision/data/output/confusable-weights.json
 */

const fs = require("node:fs");
const path = require("node:path");

const DEFAULT_JSON_PATH = path.resolve(
  __dirname,
  "../../confusable-vision/data/output/confusable-weights.json"
);

const OUTPUT_PATH = path.resolve(__dirname, "../src/confusable-weights.ts");

const jsonPath = process.argv[2] || DEFAULT_JSON_PATH;

if (!fs.existsSync(jsonPath)) {
  console.error(`Input file not found: ${jsonPath}`);
  console.error("Run confusable-vision generate-weights.ts first.");
  process.exit(1);
}

const data = JSON.parse(fs.readFileSync(jsonPath, "utf-8"));

// Build nested map: source char -> target char -> weight
const map = {};
for (const edge of data.edges) {
  const src = edge.source;
  const tgt = edge.target;

  if (!map[src]) map[src] = {};
  map[src][tgt] = {
    danger: edge.danger,
    stableDanger: edge.stableDanger,
    cost: edge.cost,
    ...(edge.glyphReuse ? { glyphReuse: true } : {}),
    ...(edge.xidContinue ? { xidContinue: true } : {}),
    ...(edge.idnaPvalid ? { idnaPvalid: true } : {}),
    ...(edge.tr39Allowed ? { tr39Allowed: true } : {}),
  };
}

// Escape a character to a safe JS string representation
function escapeChar(ch) {
  const cp = ch.codePointAt(0);
  if (cp >= 0x20 && cp <= 0x7e && ch !== '"' && ch !== "\\") {
    return ch;
  }
  if (cp <= 0xffff) {
    return "\\u" + cp.toString(16).padStart(4, "0");
  }
  // Surrogate pair for SMP characters
  const hi = Math.floor((cp - 0x10000) / 0x400) + 0xd800;
  const lo = ((cp - 0x10000) % 0x400) + 0xdc00;
  return "\\u" + hi.toString(16).padStart(4, "0") + "\\u" + lo.toString(16).padStart(4, "0");
}

// Generate TypeScript source
let ts = `// Auto-generated by scripts/generate-confusable-weights.js
// Source: confusable-vision confusable-weights.json (${data.meta.pairCount} pairs)
// Generated: ${new Date().toISOString()}
//
// DO NOT EDIT MANUALLY. Regenerate with:
//   node scripts/generate-confusable-weights.js

import type { ConfusableWeight, ConfusableWeights } from "./index";

/**
 * Measured visual similarity weights for ${data.meta.pairCount} confusable pairs
 * (${data.meta.tr39PairCount} TR39 + ${data.meta.novelPairCount} novel discoveries).
 *
 * Scored across ${data.meta.fontSetId} using SSIM.
 * Each weight includes danger (max SSIM), stableDanger (p95 SSIM), cost (1 - stableDanger),
 * and identifier property flags (xidContinue, idnaPvalid, tr39Allowed).
 *
 * Import from "namespace-guard/confusable-weights" to use with confusableDistance().
 */
export const CONFUSABLE_WEIGHTS: ConfusableWeights = {\n`;

const sources = Object.keys(map).sort((a, b) => a.codePointAt(0) - b.codePointAt(0));

for (const src of sources) {
  const targets = map[src];
  const targetKeys = Object.keys(targets).sort();

  ts += `  "${escapeChar(src)}": {\n`;

  for (const tgt of targetKeys) {
    const w = targets[tgt];
    const fields = [];
    fields.push(`danger:${w.danger}`);
    fields.push(`stableDanger:${w.stableDanger}`);
    fields.push(`cost:${w.cost}`);
    if (w.glyphReuse) fields.push("glyphReuse:true");
    if (w.xidContinue) fields.push("xidContinue:true");
    if (w.idnaPvalid) fields.push("idnaPvalid:true");
    if (w.tr39Allowed) fields.push("tr39Allowed:true");

    ts += `    "${escapeChar(tgt)}": {${fields.join(",")}},\n`;
  }

  ts += "  },\n";
}

ts += "};\n";

fs.writeFileSync(OUTPUT_PATH, ts);

const stats = fs.statSync(OUTPUT_PATH);
console.log(`Generated: ${OUTPUT_PATH}`);
console.log(`  ${data.meta.pairCount} pairs from ${sources.length} source characters`);
console.log(`  File size: ${(stats.size / 1024).toFixed(1)} KB`);
